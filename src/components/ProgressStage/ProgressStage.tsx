import React, { useEffect, useState } from 'react';
import { Toast } from '@uc/cx.react';

import { Centered, Header } from '@/components/common';
import { useGlobalContext, useStateContext } from '@/hooks';
import {
  Media,
  JobStatus,
  ClipType,
  VideoClip,
  GlobalContextValue,
  StateContextValue,
  MusicTrack,
} from '@/types';
import { APP_BASE_URL, MUSIC_TRACKS, NUM_IMAGES_REQUIRED, STAGE } from '@/constants';
import {
  trackProgressPageViewed,
  formatAddressTitleForApiService,
  formatTextForApiService,
  generateMultiLineTextList,
} from '@/utils';

import {
  handleCheckStatusWithAIVideoGenerator,
  handleGenerateWithAIVideoGenerator,
} from '@/server/middlewares/generate';
import { ProgressState, ProgressStep } from './ProgressStep';
import { getBestImages } from './getBestImages';

const PROGRESS_STEPS = [
  'Gathering images',
  'Adding smart text and music',
  'Applying effects and transitions',
  'Finalizing video',
];

export function ProgressStage(): JSX.Element {
  const { agentInfo } = useGlobalContext() as GlobalContextValue;
  const {
    listings,
    address,
    media,
    music,
    preferences,
    autoGenerated,
    videoUrl,
    setMedia,
    setMusic,
    setStage,
    setVideoUrl,
    setThumbnailUri,
  } = useStateContext() as StateContextValue;
  const [step, setStep] = useState(0);
  const [error, setError] = useState(false);

  function chooseRandomTrack(): MusicTrack {
    const categoryIndex = Math.floor(Math.random() * MUSIC_TRACKS.length);
    const category = MUSIC_TRACKS[categoryIndex];
    const trackIndex = Math.floor(Math.random() * category.tracks.length);
    return category.tracks[trackIndex];
  }

  function handleDetectRoomTypes(): void {
    const requestOptions: RequestInit = {
      headers: {
        'Content-type': 'application/json',
      },
      method: 'POST',
      body: JSON.stringify({
        media: listings[0].media,
      }),
    };

    fetch(`${APP_BASE_URL}/api/roomtype`, requestOptions)
      .then((res) => res.json())
      .then((results: { image?: Media; roomType?: string; roomTypeScore?: number }[]) => {
        const imagesByType = new Map();
        results.forEach((result) => {
          const { image, roomType, roomTypeScore } = result;
          if (image && roomType && roomTypeScore) {
            const options = imagesByType.has(roomType) ? imagesByType.get(roomType) : [];

            // Insert the new option so the array is sorted by decreasing roomtype score.
            let index = options.length;
            for (let i = 0; i < options.length; i += 1) {
              if (roomTypeScore > options[i].roomTypeScore) {
                index = i;
                break;
              }
            }

            // Use the image object attached to the listing for consistency
            const listingWithImage = listings.find((listing) =>
              listing.media!.some((m) => m.originalUrl === image.originalUrl)
            );
            const imageFromListing = listingWithImage?.media!.find(
              (m) => m.originalUrl === image.originalUrl
            );
            if (!imageFromListing) {
              // eslint-disable-next-line no-console
              console.error(`No listing image found with originalUrl "${image.originalUrl}"`);
              setError(true);
            }

            options.splice(index, 0, { image: imageFromListing, roomTypeScore });
            imagesByType.set(roomType, options);
          }
        });
        const bestImages = getBestImages(listings, imagesByType);
        if (bestImages.length < NUM_IMAGES_REQUIRED) {
          setError(true);
        } else {
          setStep(1);
          setMedia(bestImages);
        }
      })
      .catch(() => setError(true));
  }

  function createVideoClips(): VideoClip[] {
    const { subtitle } = address;
    const { showAgentBranding, showCompassLogo } = preferences;
    const clips: VideoClip[] = [];
    if (!media || media.length <= 0) {
      return [];
    }

    // Add Cover Clip
    const coverClip: VideoClip = {
      type: ClipType.TEMPLATE_COVER,
      imageUrl: media[0].originalUrl,
      addressStreetLine: formatAddressTitleForApiService(address),
      addressCityLine: formatTextForApiService(subtitle),
    };
    clips.push(coverClip);

    // Add Image Clips
    for (let i = 1; i < media.length; i += 1) {
      const imageClip: VideoClip = {
        type: ClipType.TEMPLATE_IMAGE_WITH_TEXT,
        imageUrl: media[i].originalUrl,
        text: media[i].note ? formatTextForApiService(media[i].note) : [],
        showFootage: media[i].showFootage, // Currently the generator is not supporting this
      };
      clips.push(imageClip);
    }

    // Add agent card
    if (showAgentBranding) {
      const { name, details, agentAvatarUrl, agentLogoUrl } = agentInfo;
      const agentCardClip: VideoClip = {
        type: ClipType.TEMPLATE_AGENT_CARD,
        agentName: name,
        agentDetails: generateMultiLineTextList(details),
        agentProfileUrl: agentAvatarUrl,
        agentLogoUrl,
      };
      clips.push(agentCardClip);
    }

    // Add Compass logo
    if (showCompassLogo) {
      const endingClip: VideoClip = {
        type: ClipType.TEMPLATE_COMPASS_LOGO,
      };
      clips.push(endingClip);
    }

    return clips;
  }

  async function handleGenerate() {
    const generateVideoJobResponse = await handleGenerateWithAIVideoGenerator(
      music?.name,
      createVideoClips()
    );
    setStep(2);

    const { jobId } = generateVideoJobResponse;
    if (jobId) {
      const timer = setInterval(async () => {
        const checkStatusResponse = await handleCheckStatusWithAIVideoGenerator(jobId);
        const { jobStatus } = checkStatusResponse;
        setStep(3);

        if (error) {
          clearInterval(timer);
        } else if (
          jobStatus === JobStatus.FAILED ||
          jobStatus === JobStatus.ABORTED ||
          jobStatus === JobStatus.TIMED_OUT
        ) {
          clearInterval(timer);
          setTimeout(() => {
            setError(true);
          }, 500);
        } else if (jobStatus === JobStatus.SUCCEEDED) {
          setStep(4);
          clearInterval(timer);
          setTimeout(() => {
            // Set the video attributes before moving to the next stage.
            setVideoUrl(checkStatusResponse.video || null);
            setThumbnailUri(checkStatusResponse.thumbnailUri || null);
            setStage(STAGE.VIEW);
          }, 500);
        }
      }, 500);
    }
  }

  function getProgressState(index): ProgressState {
    if (index < step) {
      return ProgressState.COMPLETED;
    }
    if (index === step) {
      return ProgressState.IN_PROGRESS;
    }
    return ProgressState.NOT_STARTED;
  }

  useEffect(() => {
    if (media.length >= NUM_IMAGES_REQUIRED) {
      // User-generated video content already exists.
      setTimeout(() => {
        if (step === 0) {
          setStep(1);
        }
      }, 500);
      handleGenerate();
    } else {
      // Using AI to choose content the video.
      handleDetectRoomTypes();
      setMusic(chooseRandomTrack());
    }
  }, [media]);

  useEffect(() => {
    trackProgressPageViewed(listings[0], media, music, autoGenerated, videoUrl);
  }, []);

  return (
    <>
      <Centered css={{ textAlign: 'center' }}>
        <Header className="textIntent-headline1">Your video is generating</Header>
        {PROGRESS_STEPS.map((text, index) => (
          <ProgressStep
            key={text}
            state={getProgressState(index)}
            text={index === 1 && !autoGenerated ? text.replace('smart ', '') : text}
          />
        ))}
      </Centered>
      {error && (
        <Toast isOpen variant="error">
          Something went wrong. Please refresh the page and try again
        </Toast>
      )}
    </>
  );
}
